/*
 * Generates an encryption key randomly with two different functions
 * 	using different precision of the current time as seed.
 *
 *  - charset: a set of characters that can be used for the key
 *  - strength: the width of the key
 *
 * Setting the seed for the random number generator used by rand()
 * 	helps ensuring that the sequence of random numbers generated by rand()
 * 	is different each time the program runs.
 *
 * The seed is set according to the current time, which makes it unique, but
 * 	not perfectly:
 *
 * 	- Using srand(time(NULL)) (like in the first function) seeds the random
 * 		number generator with the current time in seconds.
 * 	- This means that if you call srand(time(NULL)) multiple times within
 *	  	the same second, you will get the same sequence of random numbers
 *		because the seed value does not change.
 *	- Using clock_gettime(): This function (used in the second function) can
 * 		provide nanosecond precision, depending on the clock used. This will
 *		improve the randomness of the key.
 */

# include <stdio.h>
# include <time.h> 
# include <stdlib.h>
# include <string.h>

# define DC_KEYCHARSET          "abcdefghijklmnopqrstuvwxyz" \
                                "ABCDEFGHIJKLMNOPQRSTUVWXYZ" \
                                "0123456789"

# define DC_KEY_SIZE			16

// Nanoseconds based rand()
unsigned char *generate_time_based_rand_key_nanosec(
	const char *charset, size_t strength
	) {
	unsigned char *key = malloc((strength + 1) * sizeof(char));
	if (key == NULL) return NULL;

	int charset_length = strlen(charset);

    struct	timespec ts;
    clock_gettime(CLOCK_MONOTONIC, &ts); // Get the current time

	 // Seed with nanosecond precision
    srand(ts.tv_sec * 1000000000 + ts.tv_nsec);

    for (size_t i = 0; i < strength; ++i) {
        int random_index = rand() % charset_length;
		// Pick a random position from the charset
        key[i] = charset[random_index];
    }
    key[strength] = '\0'; // Null-terminate the string

	return key;
}

// Seconds based rand()
unsigned char *generate_time_based_rand_key_sec(
	const char *charset, size_t strength
	) {
	unsigned char *key = malloc((strength + 1) * sizeof(char));
	if (key == NULL) return NULL;

	int charset_length = strlen(charset);

	srand(time(NULL));

	for (size_t i = 0; i < strength; ++i)
	{
		 int random_index = rand() % charset_length;
		 // Pick a random position from the charset
		 key[i] = charset[random_index];
	}
	key[strength] = '\0'; // null-terminate the key

	return key;
}

 int main()
 {
	unsigned char	*key_sec = generate_time_based_rand_key_sec(
		DC_KEYCHARSET, DC_KEY_SIZE
		);

	unsigned char	*key_nanosec = generate_time_based_rand_key_nanosec(
		DC_KEYCHARSET, DC_KEY_SIZE
		);

	if (!key_sec || !key_nanosec) {
		fprintf(stderr, "Failed to allocate memory.\n");
		return 1;
	}

	printf("Keygen (seconds based):\t\t%s\n", key_sec);
	printf("Keygen (nanoseconds based):\t%s\n", key_nanosec);

	free(key_sec);
	free(key_nanosec);

	return 0;
 }
